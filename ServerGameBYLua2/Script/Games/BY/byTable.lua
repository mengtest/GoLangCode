---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2018/11/1 14:59
---
--local FishServerExcel = require("mgby_fish_sever")



--local CMD_Game_pb = require("CMD_Game_pb")

ByTable = {}
function ByTable:New(tableId,gameTypeId)
    c = {
        GameID = gameTypeId,
        TableID = tableId,
        TableMax = BY_TABLE_MAX_PLAYER, --桌子容纳玩家数量
        RoomScore = 0,  --房间分数

        -- 椅子
        UserSeatArray = {},  -- 座椅对应玩家uid的哈希表 ， key ： seatID (1,2,3,4)   ，value： player
        UserSeatArrayNumber = 0,  -- 桌子上有几个玩家， 记住，这里不能用#UserSeatArray, 因为有可能中间有椅子是空的，不连续的不能用#， 本质UserSeatArray是map ；  也不能遍历， 慢

        -- 生成编号
        GenerateFishUid = 1, -- 生成鱼的uid
        GenerateBulletUid = 1, -- 生成子弹的uid

        -- 鱼
        FishArray = {},   -- 鱼的哈希表    uid, fish         --- 要注意， key 不能用数字，因为占用内存太大， goperlua的问题
        FishArrayNumber = 0,   -- 鱼数组的长度，因为是哈希，所以记录一下比较方便

        -- 子弹
        BulletArray = {},   -- 子弹的哈希表   id,  bullet         --- 要注意， key 不能用数字，因为占用内存太大， goperlua的问题
        BulletArrayNumber = 0 ,   -- 子弹数组的长度，因为是哈希，所以记录一下比较方便

        -- 生成鱼池
        DistributeArray = {},   -- 鱼的生成信息数据    key顺序生成1,2,3,4...  Distribute
        BossDistributeArray = {},   -- Boss鱼的生成信息数组 key顺序生成1,2,3,4...  Distribute

        LastRunTime = 0   -- 循环周期时间
    }
    setmetatable(c,self)
    self.__index = self
    return c
end

function ByTable:Reload(c)
    setmetatable(c, self)
    self.__index = self

    -- 如果热更新有改动成员变量的定义的话， 下面需要进行成员变量的处理
    -- 比如 1 增加了字段， 那么你需要将老数据进行， 新字段的初始化
    -- 比如 2 删除了字段， 那么你需要将老数据进行， 老字段=nil
    -- 比如 3 修改了字段， 那么你需要将老数据进行， 老字段=nil， 新字段初始化或者进行赋值处理
end

------------主循环-------------------
function ByTable:StartTable()
    self:InitTable()        -- 可以进行初始化
end

GlobalMap= {}

-- 桌子的主循环
function ByTable:RunTable()
    if self:CheckTableEmpty() then
        --print("这是一个空桌子")
        --print("FishServerExcel[101].type"..FishServerExcel["101"].type)

        -- 这部分是做一个内存的测试
        ---- create Global Map hash
        --for i=1,40 do
        --    GlobalMap[tostring(i)] = i
        --end
        --
        --for i=1,40 do
        --    GlobalMap[tostring(i)] = nil
        --end

        --table.foreach(GlobalMap,function(i,v)
        --     print(i,v)
        --end )

        --clear  Global Map hash element
        --for i,_ in pairs(GlobalMap)do
        --    GlobalMap[tostring(i)] = nil        -- memery leak
        --end
        --
        --

        ---- if you clear all data, it's ok, but,  if you clear some data,  memery leak
        ----GlobalMap = {}
        --collectgarbage()

        self.LastRunTime = GetOsTimeMillisecond()
    else
        local now = GetOsTimeMillisecond()

        if self:GetFishNum() < MAX_Fish_NUMBER then
            self:RunDistributeInfo(table.RoomScore)
            self:RunBossDistributeInfo(table.RoomScore)
        end
        for _, bullet in pairs(self.BulletArray) do
            if now > bullet.DeadTime then
                self:DelBullet(bullet.BulletUID)     -- 生存时间已经到了，销毁
            end
            --bullet:BulletRun(now,self)      -- 遍历所有子弹，并且run
        end
        for _, fish in pairs(self.FishArray) do
            if now > fish.DeadTime then
                --print("鱼生存时间到了",self.FishUID)
                self:DelFish(fish.FishUID)
            end
            --fish:FishRun(now,self)              --遍历所有鱼，并且run
        end

        -- 记录桌子的运行状态
        if now - self.LastRunTime > 1000 * 60  then     -- 60秒记录一次
            local state = {}
            state["FishNum"] = self:GetFishNum()        --当前有多少条鱼
            state["BulletNum"] = self:GetBulletNum()    --当前有多少子弹
            state["SeatArray"] = self.UserSeatArrayNumber    --当前有多少玩家
            SqlSaveGameState(self.GameID, self.TableID, state)
            self.LastRunTime = now
            --print("记录桌子的运行状态")
        end
        -- 检查玩家的情况，如果玩家长期离线，那么t掉，没人就清空桌子
        --for k, player in pairs(self.UserSeatArray) do
        --    if player.NetWorkState == false then
        --        if now - player.NetWorkCloseTimer > ConstPlayerNetworkWaitTime then
        --            -- 玩家长时间断线，t掉吧
        --            self:PlayerStandUp(player.ChairID,player)
        --            Logger("长时间断线， t掉这个玩家"..player.User.UserId)
        --        end
        --    end
        --end
        end
end



function ByTable:InitTable()
    if self:CheckTableEmpty() then
        -- 如果桌子是空的， 那么需要初始化一下
        self:InitDistributeInfo()
    end
end


--- 判断玩家是否捕到鱼的逻辑判断   LockFishIdList 是保存fishId 的数组
function ByTable:LogicCatchFish(player, LockFishIdList, BulletId)
--    print("玩家申请捕鱼")

    local bullet = self:GetBullet(BulletId)
    if bullet == nil then
        LuaNetWorkSendToUser(player.User.UserId,MDM_GF_GAME, SUB_S_CATCH_FISH,nil,"子弹的uid不正确", nil)
        return
    end

    local ALLCurrScore = 0   -- 获得的分数
    local AllFishes = {}     -- 抓获的鱼list

    --printTable(LockFishIdList)
    for _,fishId in ipairs(LockFishIdList) do
--        print("抓鱼uid",v)
        local fish = self:GetFish(fishId)
        if fish ~= nil then

            -- 这里判断鱼是否可以被捕获
            local isCatchFish = false

            -- 以后增加击中鱼之后的计算
            -- ...

            isCatchFish = true

            if isCatchFish then
                fish.CurrScore = tonumber( self:GetFishScore(fish))   --鱼的分数
                ALLCurrScore = ALLCurrScore + fish.CurrScore

                table.insert(AllFishes,fish)
                --AllFishes[fish.FishUID] = fish
                -- 删除鱼
                self:DelFish(fish.FishUID)
            end

        end
    end

    if #AllFishes == 0 then
        LuaNetWorkSendToUser(player.User.UserId,MDM_GF_GAME, SUB_S_CATCH_FISH,nil,"要捕获的鱼id不正确或者已经被别人捕捉了", nil)
        return
    end

    --删除子弹
    self:DelBullet(BulletId)
    -- 获得鱼的金币
    player.User.Score = player.User.Score + ALLCurrScore

    --print("获得金币",ALLCurrScore)
    --print("当前金币",player.User.Score)
    --printTable(AllFishes)


    -- 给所有玩家同步一下，这个玩家捕到鱼了
    local sendCmd = CMD_Game_pb.CMD_S_CATCH_FISH()

    for _,fish in ipairs(AllFishes) do
        local cmd = sendCmd.catch_fishs:add()
        cmd.fish_uid = fish.FishUID
        cmd.fish_score = fish.CurrScore
    end

    sendCmd.chair_id = player.ChairID
    sendCmd.bullet.bullet_id = bullet.BulletUID
    sendCmd.curr_score = player.User.Score

    --self:SendMsgToAllUsers(MDM_GF_GAME, SUB_S_CATCH_FISH,sendCmd)

    LuaNetWorkSendToUser(player.User.UserId,MDM_GF_GAME, SUB_S_CATCH_FISH,sendCmd,nil, nil)     -- 回复给玩家
    self:SendMsgToOtherUsers(player.User.UserId, sendCmd, MDM_GF_GAME, SUB_S_CATCH_FISH)                -- 同步其他人


end




----------------------------------------------------------------------------
-----------------------------消息同步-----------------------------------------
----------------------------------------------------------------------------

-----给桌上的所有玩家同步消息
function ByTable:SendMsgToAllUsers(mainCmd,subCmd,sendCmd)
    for _,player in pairs(self.UserSeatArray) do
        if player ~= nil and player.IsRobot == false and player.NetWorkState then
             --LuaNetWorkSendToUser(player.User.UserId,mainCmd,subCmd,sendCmd,nil)
            local result = LuaNetWorkSendToUser(player.User.UserId,mainCmd,subCmd,sendCmd,nil, 0)       -- 注意，这里因为是群发，所以token标记是0，就是不需要
            if not result then
                -- 发送失败了，玩家网络中断了
                --player.NetWorkState = false
                --player.NetWorkCloseTimer = GetOsTimeMillisecond()
                self:PlayerStandUp(player.ChairID,player)
            end
        end
    end
end

----给桌上的其他玩家同步消息
function ByTable:SendMsgToOtherUsers(userId,sendCmd,mainCmd,subCmd)
    for _,player in pairs(self.UserSeatArray) do
        if player ~= nil and player.IsRobot == false and userId ~= player.User.UserId and player.NetWorkState then
            LuaNetWorkSendToUser(player.User.UserId,mainCmd,subCmd,sendCmd,nil, 0)       -- 注意，这里因为是群发，所以token标记是0，就是不需要
        end
    end
end


----------------------------------------------------------------------------
-----------------------------生成鱼池-----------------------------------------
----------------------------------------------------------------------------
----初始化鱼池的生成组----------------------------
function ByTable:InitDistributeInfo()
    --print("初始化鱼池")
    local startId = self.RoomScore * 100
    local endId = startId + 100
    local distribute
    for fishKind, v in pairs(FishServerExcel) do
        fishKind = tonumber(fishKind)
        if v.is_use == 1 and fishKind > startId and fishKind < endId then
            distribute = FishDistribute:New()
            distribute.FishKindID = fishKind

            distribute.CreateTime = GetOsTimeMillisecond()               --生成时间
            distribute.DistributeIntervalTime = distribute:GetIntervalTime(fishKind)      --获取时间间隔

            if distribute.DistributeIntervalTime == 0 then
                distribute.DistributeIntervalTime = 1000            -- 这里有生成间隔是0的东西
            end

            local fishType = v.type
            if fishType == FT_BOSS then
                table.insert(self.BossDistributeArray, distribute)  --加入到Boss鱼生成列表中
            else
                table.insert(self.DistributeArray, distribute)      --加入到普通鱼生成列表中
            end
        end
    end
--    print("桌子初始化鱼池结束")
end

----循环鱼池的生成组
function ByTable:RunDistributeInfo(roomScore)
    --print("循环鱼池生成组")
    local now = GetOsTimeMillisecond()
    local fish_number = 0
    local fish_number_max = 4       -- 每秒最多几条鱼

    for _,Distribute in pairs(self.DistributeArray) do
        local kindId = Distribute.FishKindID
        -- 到下一个生成时间了, 那么我们来生成鱼吧

        --print("now",now,"Distribute.CreateTime",Distribute.CreateTime, " Distribute.DistributeIntervalTime", Distribute.DistributeIntervalTime)

        if now >  Distribute.CreateTime + Distribute.DistributeIntervalTime then
            --print("生成时间到了")
            --print("now",now,"Distribute.CreateTime",Distribute.CreateTime, " Distribute.DistributeIntervalTime", Distribute.DistributeIntervalTime)
            local createType = 0   --鱼怎么走
            local buildNum = 0      -- 鱼生成数量
            local max = FishServerExcel[tostring(kindId)].count_max
            if max > 1 then
                -- 多生成几条鱼
                buildNum =  Distribute:GetCount(kindId)
--                print("随机生成"..buildNum.."条鱼")
                if buildNum < 1 then
                    buildNum = 1
                else
                    createType = 1  --生成一条路径的
                    if buildNum >=5 or ZRandomPercentRate(50) then
                        createType = 2  --位置要做偏移
                    end
                end
                Distribute.NextCreateTime = now
                Distribute.NextInterBuildTime = Distribute:GetCountFishTime(kindId)
            end
            Distribute.BuildNumber = buildNum
            Distribute.CreateTime = now
            Distribute.DistributeIntervalTime = Distribute:GetIntervalTime(kindId)
            Distribute.CreateType = createType                  --创建类型
            Distribute.FirstPathID = Distribute:GetPathType()    -- 获取路径

            -- 创建鱼
            self:DistributeNewFish(Distribute,0,0)
            fish_number = fish_number + 1
            if fish_number >= fish_number_max then
                return
            end

        end

        -- 多条鱼的判断
        if Distribute.BuildNumber > 1 then
            if now > Distribute.NextCreateTime + Distribute.NextInterBuildTime then
--                print("生成多条鱼"..kindId)
                local offsetX = 0
                local offsetY = 0
                Distribute.NextCreateTime = now
                Distribute.BuildNumber = Distribute.BuildNumber - 1
                Distribute.NextInterBuildTime = Distribute:GetCountFishTime(kindId)
                if Distribute.CreateType == 2 then
                    -- 位置偏移
                    offsetX = Distribute:GetOffsetXY()[1]
                    offsetY = Distribute:GetOffsetXY()[2]
                end
                -- 创建鱼
                self:DistributeNewFish(Distribute,offsetX,offsetY)
                fish_number = fish_number + 1
                if fish_number >= fish_number_max then
                    return
                end
            end
        end

    end
end

-----循环Boss鱼池的生成组
function ByTable:RunBossDistributeInfo(roomScore)

    --local now = GetOsTimeMillisecond()
    --for k,Distribute in pairs(self.BossDistributeArray) do
    --    --到下一个生成时间了, 那么我们来生成鱼吧
    --    if now > Distribute.CreateTime + Distribute.DistributeIntervalTime then
    --        local kindId = Distribute.FishKindID
    --        local buildNum = 1   -- 鱼生成数量
    --        Distribute.BuildNumber = buildNum
    --        Distribute.CreateTime = now
    --        Distribute.DistributeIntervalTime = Distribute:GetIntervalTime(kindId)
    --        Distribute.FirstPathID = Distribute:GetPathType()    -- 获取路径
    --
    --        self:DistributeNewFish(Distribute,0,0)
    --    end
    --end
end

