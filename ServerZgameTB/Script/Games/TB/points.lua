---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.
--- DateTime: 2019/6/5 14:27
---

------------------------------------------------------------------------------
--- 小奖池积分赛
------------------------------------------------------------------------------

local list_max = 10     -- 积分赛的排行榜

-------------------------------------------------积分库存-------------------------------------------------

-- 积分赛库存值的增加
function PointsAdd(gameTable,add)
    -- 有一部分进入积分赛库存
    local rate = GetExcelValue(TBRoomExcel, gameTable.RoomScore, "point_ratio")
    local value = add * rate /10000
    gameTable.PointsScore = gameTable.PointsScore + value

    -- 不超过上限
    local pointsMax = GetExcelValue(TBPointExcel, gameTable.RoomScore, "max_gold" )
    if gameTable.PointsScore >= pointsMax then
        gameTable.PointsScore = pointsMax
    end
end

-- 对列表进行降序排序, 由大到小
local function tableTopListSort(tableList)
    table.sort(tableList, function (a,b)   return a.point > b.point      end)
    --print("排序完成---------------")
    --printTable(tableList)
end

---------------------------------------------定期检查小奖池的状态-------------------------------------------------------------------

-- 检查是否在活动开启时间内
local function pointsCheckIsOpenTime(gameTable)
    local hour = GetHourFromString(GetOsDateNow())  -- 当前小时数
    local start1 = GetExcelValue(TBPointExcel, gameTable.RoomScore, "open_time1")
    local end1 = GetExcelValue(TBPointExcel, gameTable.RoomScore, "end_time1")
    local start2 = GetExcelValue(TBPointExcel, gameTable.RoomScore, "open_time2")
    local end2 = GetExcelValue(TBPointExcel, gameTable.RoomScore, "end_time2")

    if hour >= start1 and hour < end1 then
        return true
    end
    if hour >= start2 and hour < end2 then
        return true
    end
    return false
end


-- 定期检查小奖池积分赛是否开启
function PointsCheckOpen(gameTable)
    if gameTable.PointsState == QD_INIT then
        if pointsCheckIsOpenTime(gameTable) then    -- 判断是否在开启时间
            local need_gold = GetExcelValue(TBPointExcel, gameTable.RoomScore, "need_gold")
            if  gameTable.PointsScore >= need_gold  then  -- 判断积分赛库存是否足够
                gameTable.PointsState = QD_READY             -- 开启积分赛，开始倒计时
                print("积分赛进入倒计时")
                SqlSaveSystemLogPoints(gameTable, "开始倒计时", gameTable.PointsScore, "")
                gameTable.PointsStateStartTime = os.time()      -- 记录当前时间戳，精度为妙
                SystemTipLocalStringIndexSendToAllPlayers(1)        -- 发送跑马灯，告诉玩家积分赛进入倒计时
                for i=1,list_max do
                    gameTable.PointsTopList[i] = {}
                    gameTable.PointsTopList[i].uid = 0
                    gameTable.PointsTopList[i].point = 0
                end
                gameTable.PointsAllPlayer = {}          -- 初始化参与人列表
                gameTable.PointsPlayerNumber = 0        -- 初始化参与人数

                gameTable.PointsStateRemainTime = GetExcelValue(TBPointExcel, gameTable.RoomScore, "wait_time")
                PointsSendMsgToAllPlayer(gameTable)     -- 同步消息，进入准备阶段
            end
        end
    end

    -- 判断是否开启
    if gameTable.PointsState == QD_READY then
        if os.time() > gameTable.PointsStateStartTime + gameTable.PointsStateRemainTime  then        -- 等60秒，判断是否开启
            print("积分赛开启")
            SqlSaveSystemLogPoints(gameTable, "积分赛开始", gameTable.PointsScore, "")
            SystemTipLocalStringIndexSendToAllPlayers(1)        -- 发送跑马灯，告诉玩家积分赛开始了
            gameTable.PointsState = QD_OPEN                  -- 开始
            gameTable.PointsStateStartTime = os.time()      -- 记录当前时间戳，精度为妙
            gameTable.PointsStateRemainTime = GetExcelValue(TBPointExcel, gameTable.RoomScore, "continue_time")
        else
            --print("准备阶段剩余时间"..gameTable.PointsStateRemainTime - (os.time() - gameTable.PointsStateStartTime) )
        end
    end

    -- 判断是否到结束时间
    if gameTable.PointsState == QD_OPEN then
        if os.time() > gameTable.PointsStateStartTime + gameTable.PointsStateRemainTime then        -- 是否到结束时间了
            print("积分赛结束，开始结算")
            gameTable.PointsState = QD_END             -- 积分赛结束，进入休眠状态
            gameTable.PointsStateStartTime = os.time()      -- 记录当前时间戳，精度为妙
            gameTable.PointsStateRemainTime = GetExcelValue(TBPointExcel, gameTable.RoomScore, "open_cd")
            PointsSendMsgToAllPlayer(gameTable)     -- 同步消息, 活动结束，进入休眠

            -- 结算积分获得
            PointsEndReward(gameTable)

            -- 日志记录
            SqlSaveSystemLogPoints(gameTable, "积分赛结束，开始发奖励", gameTable.PointsScore, ZJson.encode(gameTable.PointsTopList))

        else

            --print("活动结束剩余时间"..remain_time )
            PointsSendMsgToAllPlayer(gameTable)     -- 同步消息, 同步积分情况
        end
    end

    -- 判断是否结束休眠
    if gameTable.PointsState == QD_END then
        if os.time() > gameTable.PointsStateStartTime + gameTable.PointsStateRemainTime then        -- 是否结束休眠
            print("休眠阶段结束， 开始进入准备阶段")
            gameTable.PointsState = QD_INIT                 -- 进入准备阶段
        else
            --print("休眠剩余时间"..gameTable.PointsStateRemainTime - (os.time() - gameTable.PointsStateStartTime) )
        end
    end


end

-------------------------------------------------获得积分-------------------------------------------------

-- 判断是否获得小奖池积分赛积分，每个玩家在每次中老虎机，翻牌，轮盘，热血模式的时候
function PointCheckGetPoints(player, gold_add)
    local gameTable = player:GetTable()

    local PointsTopList = gameTable.PointsTopList
    if gameTable.PointsState == QD_OPEN then
        -- 如果积分赛开启，那么增加到排行中

        -- 先把玩家的积分都保存起来
        if gameTable.PointsAllPlayer[tostring(player.User.UserId)] == nil then
            gameTable.PointsAllPlayer[tostring(player.User.UserId)] = gold_add        -- 不存在就新建
            gameTable.PointsPlayerNumber = gameTable.PointsPlayerNumber + 1         -- 玩家参与数量加1
        else
            gameTable.PointsAllPlayer[tostring(player.User.UserId)] = gameTable.PointsAllPlayer[tostring(player.User.UserId)] + gold_add        -- 存在就加上
        end
        local player_point = gameTable.PointsAllPlayer[tostring(player.User.UserId)]        -- 玩家的积分
        --print("玩家积分为"..player_point)

        -- 上榜判断
        if player_point > PointsTopList[list_max].point then
            -- 情况1， 如果排名数组里面存在这个玩家，那么需要更新，不是添加
            for i=1,list_max do
                if PointsTopList[i].uid == player.User.UserId then
                    --print("更新上榜玩家积分")
                    PointsTopList[i].point = player_point
                    tableTopListSort(PointsTopList)        -- 重新排序
                    return      --存在这个玩家，要么更新，要么不做
                end
            end
            -- 情况2， 如果当前玩家库存大于最高的几个人中最小的一个，那么替换掉那个人
            --print("玩家积分上榜")
            PointsTopList[list_max].point = player_point
            PointsTopList[list_max].uid = player.User.UserId
            tableTopListSort(PointsTopList)        -- 重新排序
        end

    end
end


-------------------------------------------------消息同步-------------------------------------------------

-- 发消息给玩家
function PointsSendMsgToAllPlayer(gameTable)
    for _,player in pairs(AllPlayerList) do
        if player.GameType ==  gameTable.GameID then
            -- 是同一个房间的玩家，那么推送
            PointsSendMsgToPlayer(player,gameTable)
        end
    end
end


-- 发送小奖池信息给单个玩家
function PointsSendMsgToPlayer(player,gameTable)
    local sendCmd = CMD_Game_TB_pb.CMD_S_QUALIFYING_DATA()
    sendCmd.mark = gameTable.PointsState            -- 小奖池的状态
    sendCmd.award_pool = gameTable.PointsScore          -- 小奖池库存
    sendCmd.start_time = gameTable.PointsStateStartTime     -- 开始时间

    if gameTable.PointsState ~= QD_OPEN then
        sendCmd.remain_time = gameTable.PointsStateRemainTime     -- 持续时间
    else
        sendCmd.remain_time = gameTable.PointsStateRemainTime - (os.time() - gameTable.PointsStateStartTime)        -- 如果是运行状态，那么同步剩余时间
    end


    if gameTable.PointsAllPlayer[tostring(player.User.UserId)] ~= nil then
        sendCmd.user_data.q_value = gameTable.PointsAllPlayer[tostring(player.User.UserId)]     -- 积分
        sendCmd.user_data.q_rank = 0
        for i=1,list_max do
            if gameTable.PointsTopList[i].uid == player.User.UserId then        -- 在榜上
                sendCmd.user_data.q_rank = i        -- 排名
                break
            end
        end
    else
        sendCmd.user_data.q_value = 0       -- 没有参加活动
        sendCmd.user_data.q_rank = 0
    end

    sendCmd.user_num = gameTable.PointsPlayerNumber

    for i in ipairs(gameTable.PointsTopList) do
        local this_uid = gameTable.PointsTopList[i].uid
        if this_uid ~= 0 then
            local top_user = sendCmd.user_data_top:add()
            top_user.q_rank = i
            top_user.q_value = gameTable.PointsTopList[i].point

            top_user.user_id = this_uid
            local this_player = GetPlayerByUID(this_uid)
            if this_player == nil then
                -- 说明玩家不在线， 那么读redis
                print("this_uid"..this_uid)
                local this_user = RedisGetUserData(this_uid)
                top_user.name = this_user.NickName
            else
                top_user.name = this_player.User.NickName
            end
        end
    end

    local rank_info1 = sendCmd.rank_info:add()
    rank_info1.award_rank = "1"
    rank_info1.award_score = math.floor(PointsRewardList[1] *  gameTable.PointsScore /100)
    local rank_info2 = sendCmd.rank_info:add()
    rank_info2.award_rank = "2"
    rank_info2.award_score = math.floor(PointsRewardList[2] *  gameTable.PointsScore /100)
    local rank_info3 = sendCmd.rank_info:add()
    rank_info3.award_rank = "3-5"
    rank_info3.award_score = math.floor(PointsRewardList[3] *  gameTable.PointsScore /100)
    local rank_info4 = sendCmd.rank_info:add()
    rank_info4.award_rank = "6-10"
    rank_info4.award_score = math.floor(PointsRewardList[4] *  gameTable.PointsScore /100)

    LuaNetWorkSendToUser(player.User.UserId, MDM_GF_GAME_TB, SUB_S_POINTS_INFO, sendCmd, nil, nil)
end

-------------------------------------------------积分结算-------------------------------------------------


-- 发奖结算
function PointsEndReward(gameTable)
    local function sendReward(uid, gameTable, score, rank)
        local player = GetPlayerByUID(uid)
        if player ~= nil then
            if player.GameType == gameTable.GameID then
                -- 玩家在线，那么直接发
                ScoreAdd(player, score )
                return
            end
        end
        MailSystemSendToPlayer(uid , "Congratulations! You get "..score.." Gold in "..gameTable.RoomScore.." Room by Rank "..rank.." !" , score)
    end

    if gameTable.PointsTopList[1].uid ~= 0 then
        local score = math.floor(PointsRewardList[1] *  gameTable.PointsScore /100)
        sendReward(gameTable.PointsTopList[1].uid , gameTable, score, 1)
        --MailSystemSendToPlayer(gameTable.PointsTopList[1].uid , "Congratulations! You get "..score.." Gold!" , score)
    end
    if gameTable.PointsTopList[2].uid ~= 0 then
        local score = math.floor(PointsRewardList[2] *  gameTable.PointsScore /100)
        sendReward(gameTable.PointsTopList[2].uid , gameTable, score, 2)
        --MailSystemSendToPlayer(gameTable.PointsTopList[2].uid , "Congratulations! You get "..score.." Gold!" , score)
    end
    for i=3,5 do
        if gameTable.PointsTopList[i].uid ~= 0 then
            local score = math.floor(PointsRewardList[3] *  gameTable.PointsScore /100)
            sendReward(gameTable.PointsTopList[i].uid , gameTable, score, i)
            --MailSystemSendToPlayer(gameTable.PointsTopList[i].uid , "Congratulations! You get "..score.." Gold!" , score)
        end
    end
    for i=6,10 do
        if gameTable.PointsTopList[i].uid ~= 0 then
            local score = math.floor(PointsRewardList[4] *  gameTable.PointsScore /100)
            sendReward(gameTable.PointsTopList[i].uid , gameTable, score, i)
            --MailSystemSendToPlayer(gameTable.PointsTopList[i].uid , "Congratulations! You get "..score.." Gold!" , score)
        end
    end
end