---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.
--- DateTime: 2019/6/1 11:29
---

-- 整点领取金币
function HandleGetClockScore(userId,data)
    local player = GetPlayerByUID(userId)

    local msg = CMD_GameServer_pb.CMD_C_Clock_Gold()
    msg:ParseFromString(data)
    local index = msg.index

    local sendCmd = CMD_GameServer_pb.CMD_S_Clock_Gold()

    local today_last  -- 今天和上次领取的时间差
    if player.User.GoldByClockLastTime == "" then        -- 如果没有上次领取记录
        today_last = 1      -- 如果没有领取记录， 那么就认为今天没有领取过
    else
        today_last = GetTwoTimesDays(GetTimeFromString(player.User.GoldByClockLastTime) , os.time())     -- 有签到记录，那么就用计算的值
    end

    if today_last > 0 then
        -- 今天没有领取过， 那么重置数组
        player.User.GoldByClockRecordList[1] = 0
        player.User.GoldByClockRecordList[2] = 0
        player.User.GoldByClockRecordList[3] = 0
    end

    if index <= 0 then
        -- 申请列表
        for i=1,3 do
            sendCmd.clock_list:append( player.User.GoldByClockRecordList[i])
        end
    else
        -- 申请领取
        -- 判断是否领取过，判断是否在时间内
        if index > 3 then
            LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_CLOCK_GOLD, nil, "index must in 1,2,3", nil)
            return
        else
            if player.User.GoldByClockRecordList[index] ==0 then        --没有领取过
                local time_min = GetExcelValue(TBGetGoldByTimeExcel, index, "time_open")
                local time_max = GetExcelValue(TBGetGoldByTimeExcel, index, "time_close")
                local time_gold = GetExcelValue(TBGetGoldByTimeExcel, index, "gold")
                local now_hour = GetHourFromString( GetOsDateNow())     -- 获取当前小时
                print("当前为几点"..now_hour)

                if now_hour >= time_min and now_hour < time_max  then        -- 在时间内
                --if true then
                    -- 符合条件，开始领取
                    player.User.GoldByClockRecordList[index] = 1        -- 领取过了
                    player.User.GoldByClockLastTime = GetOsDateNow()        -- 记录上次领取时间

                    -- 增加vip倍率
                    local vip_multi = GetExcelValue(TBVIPExcel, player.User.VipLevel, "clock_rewards")
                    sendCmd.vip_multi = vip_multi

                    -- 增加分数
                    ScoreAdd(player, time_gold * vip_multi)
                    sendCmd.score = time_gold                -- 这个还是发基础值， 让客户端做一个乘法来显示
                    sendCmd.player_score = ScoreGet(player)

                    -- 玩家整点领取金币流水日志
                    SqlSaveUserGetGoldByClockLog(player,now_hour.."点领取金币", time_gold )

                    SqlSaveSystemLogClock(0 , now_hour.."点领取金币" , time_gold , player.User.UserId)        -- 系统记录日志

                else
                    -- 不在规定时间内
                    LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_CLOCK_GOLD, nil, "get time is error", nil)
                    return
                end
            else
                -- 已经重复领取
                LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_CLOCK_GOLD, nil, "already get this gold", nil)
                return
            end
        end
    end


    sendCmd.index = index
    LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_CLOCK_GOLD, sendCmd, nil, nil)

    -- 记录玩家数据
    RedisSavePlayerAll(player.User)



end

-- 签到
function  HandleGetSignInScore(userId,data)
    local player = GetPlayerByUID(userId)

    local msg = CMD_GameServer_pb.CMD_C_Sign_In()
    msg:ParseFromString(data)
    local index = msg.index     -- 如果签到index为0，那么就不签到，只是返回列表

    local sendCmd = CMD_GameServer_pb.CMD_S_Sign_In()
    if index == 0 then      -- 第一次进入请求玩家情况和数据列表
        -- 客户端发送index为0，返回数据列表

        for i = 1,7 do
            sendCmd.sign_list:append( GetExcelValue(TBSignInRewardExcel,i, "reward" ))
        end
    else
        -- 客户端申请签到
        local today_last  -- 今天和上次签到的时间差
        if player.User.SignInLastTime == "" then        -- 如果没有上次签到
            today_last = 2      -- 如果没有签到记录， 那么就认为不连续签到即可
        else
            today_last = GetTwoTimesDays(GetTimeFromString(player.User.SignInLastTime) , os.time())     -- 有签到记录，那么就用计算的值
        end

        if  today_last > 0 then    -- 今天和上次签到的时间差多于1天
            -- 签到成功
            if today_last == 1 then     -- 昨天签到过了
                -- 连续签到
                player.User.SignInAllTimes =  player.User.SignInAllTimes + 1        -- 连续签到更新
                player.User.SignInIndex = player.User.SignInIndex + 1        -- 位置更新
                if player.User.SignInIndex > 7 then
                    player.User.SignInIndex = 7
                end
            else
                -- 未连续签到
                player.User.SignInAllTimes =  1
                player.User.SignInIndex = 1
            end

            --获得奖励
            local gold = GetExcelValue( TBSignInRewardExcel , player.User.SignInIndex , "reward")


            -- 增加vip倍率
            local vip_multi = GetExcelValue(TBVIPExcel, player.User.VipLevel, "sign_in_bonus")
            sendCmd.vip_multi = vip_multi

            ScoreAdd(player, gold * vip_multi)

            player.User.SignInLastTime = GetOsDateNow()

            sendCmd.score = gold            -- 这个还是发基础值， 让客户端做一个乘法来显示
            sendCmd.player_score =  ScoreGet(player)


            -- 玩家行为流水日志
            SqlSaveUserGetSignInLog(player, gold ,0 )

            SqlSaveSystemLogSignIn(0  , "连续签到天数"..player.User.SignInAllTimes , gold , player.User.UserId)       -- 系统记录日志
        else
            -- 重复签到，今天已经签到过了
            LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_SIGN_IN, nil, "today already signed", nil)
            return
        end
    end

    sendCmd.index = player.User.SignInIndex     -- 返回玩家已经签到的位置
    sendCmd.sign_times = player.User.SignInAllTimes
    if player.User.SignInLastTime ~= "" then
        sendCmd.last_sign_time =   GetTimeFromString(player.User.SignInLastTime)
    end

    LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_SIGN_IN, sendCmd, nil, nil)

    -- 记录玩家数据
    RedisSavePlayerAll(player.User)



end




-- 幸运轮盘
function HandleLuckyWheel(userId,data)
    local player = GetPlayerByUID(userId)
    local msg = CMD_GameServer_pb.CMD_C_DRAW()
    msg:ParseFromString(data)
    local index = msg.index     --0 是请求列表， 1是开始转

    local wheel_result = 0      -- 转动到第几个位置
    local wheel_value =  0          -- 获得奖励数量

    -- 判断随机次数
    local today_last  -- 今天和上次的时间差
    if player.User.LuckyWheelTime == "" then        -- 如果没有上次时间
        today_last = 2      -- 如果没有记录， 那么就认为不连续
    else
        today_last = GetTwoTimesDays(GetTimeFromString(player.User.LuckyWheelTime) , os.time())     -- 有签到记录，那么就用计算的值
    end

    if  today_last > 0 then    -- 今天和上次记录的时间差多于1天
        player.User.LuckyWheelTime = GetOsDateNow()
        player.User.LuckyWheelNum = GetExcelValue(TBVIPExcel, player.User.VipLevel, "lottery_times")
    end


    local sendCmd = CMD_GameServer_pb.CMD_S_DRAW()
    sendCmd.result_code = 0
    if index == 0 then      -- 如果请求列表，那么返回列表
        for i=1,10 do
            local draw_item = sendCmd.draw_list:add()
            draw_item.item_type = GetExcelValue(TBLuckyWheelExcel, i, "award_type")
            draw_item.item_sub_type = GetExcelValue(TBLuckyWheelExcel, i, "award_sub_type")
            draw_item.item_value = GetExcelValue(TBLuckyWheelExcel, i, "award_value")
        end
        sendCmd.score = 0

    else    -- 转动轮盘
        --if player.User.LuckyWheelNum > 0  then    -- 如果还有剩余次数
        if true  then    -- 如果还有剩余次数
            --if LotteryGet(player)  >=  LuckyWheelCostLottery then    -- 如果奖券数量足够
            if true then    -- 如果奖券数量足够
                local rand = GetRandom(1,10000)
                for i =1,10 do
                    local rate = GetExcelValue(TBLuckyWheelExcel, i, "award_rate")
                    if rand <= rate then
                        -- 就是这种类型了
                        wheel_value = GetExcelValue(TBLuckyWheelExcel, i, "award_value")
                        wheel_result = i

                        -- 发奖
                        local item_type = GetExcelValue(TBLuckyWheelExcel, i, "award_type")
                        local item_sub_type = GetExcelValue(TBLuckyWheelExcel, i, "award_sub_type")

                        if item_type == 1 then          --1-资源  2-道具    3-实物
                            if item_sub_type == 1 then  -- 资源类型对应子类型1-金币2-奖券 实物类型对应子类型1-话费2-京东卡3-手机
                                ScoreAdd(player,wheel_value )
                                sendCmd.score = wheel_value
                                SqlSaveUserGetGoldByLuckyWheelLog(player, wheel_value )       -- 幸运轮盘抽奖流水日志
                                SqlSaveSystemLogLuckyWheel(0 , "幸运轮盘"..wheel_result , wheel_value , player.User.UserId)       -- 系统记录日志
                            end
                        end
                        --player.User.LuckyWheelNum = player.User.LuckyWheelNum - 1       -- 抽奖次数减少
                        --LotteryReduce(player, LuckyWheelCostLottery)                     -- 奖券减少

                        player.User.Lottery = 999999
                        player.User.LuckyWheelNum = 28

                        -- 增加到历史记录中
                        LuckyWheelHistoryListAdd(player.User.NickName , wheel_result)

                        sendCmd.result_code = 1
                        break
                    end
                end

            end
        end
    end

    sendCmd.player_score = ScoreGet(player)
    sendCmd.wheel_result = wheel_result         --轮盘结果index

    sendCmd.can_wheel_num = player.User.LuckyWheelNum       -- 随机次数
    sendCmd.max_wheel_num = GetExcelValue(TBVIPExcel, player.User.VipLevel, "lottery_times")        -- 最多次数
    sendCmd.player_lottery = LotteryGet(player)         -- 奖券数量
    sendCmd.cost_lottery = LuckyWheelCostLottery        -- 消耗奖券数量

    sendCmd = LuckyWheelHistoryListGet(sendCmd)         -- 获取历史记录

    LuaNetWorkSendToUser(userId, MDM_GF_GAME_TB, SUB_S_LUCKY_WHEEL, sendCmd, nil, nil)

    -- 记录玩家数据
    RedisSavePlayerAll(player.User)
end